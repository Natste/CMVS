clf; close all; clear frames;
%% Load CSV files
DATA_FILE = 'data1.csv';
OUTPUT_DIR = 'output';
MATRIX_TYPE = 'normalized';
I_DATA_START = 1;
I_DATA_END = 61;
I_DELTA = I_DATA_END - I_DATA_START;
PEAK_DISTANCE = 50;
PEAK_PROMINENCE = 0.15;%0.016;
PEAK_WIDTH = 15;
SCALE = 150;
DATA_WINDOW = 10; % TODO: figure why this var was referred to as 'window'
FILTER_WINDOW = 11;
THRESHOLD = 0.03;

if ~isfile(DATA_FILE)
  DATA_FILE = uigetfile('*.csv;*.txt;*.dat', 'Select Input CSV Data', 'data.csv');
end
if ~isfolder(OUTPUT_DIR)
  OUTPUT_DIR = uigetdir('.', 'Select Output Directory');
end


% Read and transfer raw lux data to new array
data = readmatrix(DATA_FILE);
nNotNan  = sum(~isnan(data),2);
nSensors = round(mean(nNotNan));
data = data(nNotNan == nSensors, :);
data = rmmissing(data, 2);

%% Set test parameters
if DATA_WINDOW > length(data)
    DATA_WINDOW = length(data);
    dataWindowWarn = sprintf("DATA_WINDOW exceeds length of data and has been trimmed");
else
    dataWindowWarn = sprintf('');
end
if FILTER_WINDOW > length(data)
    FILTER_WINDOW = length(data);
    filterWindowWarn = sprintf("FILTER_WINDOW exceeds length of data and has been trimmed");
else
    filterWindowWarn = sprintf('');
end
if I_DATA_END > length(data)
    I_DATA_END = length(data);
    I_DATA_START = max(I_DATA_END - I_DELTA, 1);
    dataEndWarn = sprintf("I_DATA_END exceeds length of data. Range parameters have been changed");
else
    dataEndWarn = sprintf('');
end
if ~ismissing([dataWindowWarn, filterWindowWarn, dataEndWarn])
    warning('\n\t%s\n\t%s\n\t%s', dataWindowWarn, filterWindowWarn, dataEndWarn);
end

%% Get framed dataset
dataSample =  get_sample_range(data, I_DATA_START, I_DATA_END);

%% Normalize data
dataSampleNorm =  get_norm(dataSample);

%% Filter and de - noise data
smoothSample = smoothdata(dataSample, 'sgolay', FILTER_WINDOW);
smoothSampleNorm = smoothdata(dataSampleNorm, 'sgolay', FILTER_WINDOW);

%% Plot and save datasets
axFmt.FontSize = 15;
axFmt.FontWeight = 'bold';
axFmt.YLim = [0 inf];
figFmt.Units = 'Normalized';
figFmt.Visible = false;
figFmt.OuterPosition = [0, 0.04, 0.25, 0.25];
compassStrings = {' S' 'SW' 'SE'
                  ' N' 'NW' 'NE'
                  ' O' ' W' ' E'};
figure(figFmt);
plotSets = {data
            dataSample
            smoothSample
            smoothSampleNorm};

dataPlotFmt.LineWidth = 2;
for iPlotSet = 1:length(plotSets)
  dataPlot = plot(plotSets{iPlotSet});
  for iSensor = 1:nSensors
    dataPlotFmt.DisplayName = compassStrings{iSensor};
    set(dataPlot(iSensor), dataPlotFmt);
  end
  % modify labels for tick marks
  legend('show');
  dataAx = gca;
  dataAx.XLabel.String = 'Time Elapsed (milliseconds)';
  dataAx.YLabel.String = 'Irradiance (W/m^2)';
  dataAx.XTickLabel = arrayfun(@(x) sprintf('%d', SCALE * x), dataAx.XTick, 'un', 0);
  set(dataAx, axFmt);
  % Save figure and image in folder
  saveas(gca, fullfile(OUTPUT_DIR, 'Dataset'), 'fig');
  saveas(gca, fullfile(OUTPUT_DIR, 'Dataset'), 'png');
  close
end

%% Find peaks and dips
t = (I_DATA_START:I_DATA_END); %/ Fs
peakArr = zeros(nSensors, 1);
peakLocArr = zeros(nSensors, 1);

dipArr = zeros(nSensors, 1);
dipLocArr = zeros(nSensors, 1);

% Peak and dip parameters
dipFmt.MinPeakDistance = PEAK_DISTANCE;
dipFmt.MinPeakProminence = PEAK_PROMINENCE;
dipFmt.NPeaks = PEAK_WIDTH;

% Plot local maxima and minima
sensorPlot = repelem(0, nSensors);
figure(figFmt);

hold on
for iSensor = 1:nSensors
    sensorInv = 1 ./ smoothSampleNorm(:, iSensor);
    [dip, dipLoc] = findpeaks(sensorInv, dipFmt);

    if isempty(dipLoc)
        dipLocArr(iSensor) = 0;
    else
        dipLocArr(iSensor) = dipLoc;
    end

    sensorPlot(iSensor) = plot(t, smoothSampleNorm(:, iSensor), 'DisplayName', 'Origin Sensor', 'LineWidth', 2);
    set(sensorPlot(iSensor), dataPlotFmt);
    plot(t(dipLoc), 1 / dip, 'rs', 'MarkerSize', 10);
end
hold off
sensorAx = gca;
set(sensorAx, axFmt);
sensorAx.XLabel.String = 'Time Elapsed (milliseconds)';
sensorAx.YLabel.String = 'Normalized Irradiance';
sensorAx.XTickLabel = arrayfun(@(x) sprintf('%d', SCALE * x), sensorAx.XTick, 'un', 0);
saveas(gca, fullfile(OUTPUT_DIR, 'CMV_Sample_Norm'), 'fig');
saveas(gca, fullfile(OUTPUT_DIR, 'CMV_Sample_Norm'), 'png');

%% Get lux matrix
if strcmp(MATRIX_TYPE, 'normalized')
  inputArray
  luxMatrix =  get_matrix(smoothSampleNorm, DATA_WINDOW);
else
  luxMatrix =  get_matrix(smoothSample, DATA_WINDOW);
end

fillmissing(luxMatrix, 'makima');

%% Find cmv direction using Gradient Matrix Method
pages = length(luxMatrix);                                              %find maxnumber of frames
imData =  luxMatrix(:, :, 1:pages);                                            %set dataset to be analyzed
[imageRow, imageCol, ~] = size(imData);
theta = zeros(imageRow, imageCol, pages);
magnitude = zeros(imageRow, imageCol, pages);
theta2 = repelem(0, pages);
frames(pages) = struct('cdata',[],'colormap',[]);
figure(figFmt);
set(gcf, Visible = false);
progressBar = waitbar(0, '1', Name='Creating Video');
v = VideoWriter(strcat(OUTPUT_DIR, 'GradientMatrix'));
open(v);
for iFrame = 1:(pages - 1)
    waitbar(iFrame/DATA_WINDOW, progressBar, sprintf("Frame %6d / %6d", iFrame, pages - 1));
    [gx, gy] = imgradientxy( imData(:, :, iFrame), 'sobel');
    [gmag, gdir] = imgradient(gx, gy);

    theta(:, :, iFrame) = gdir;
    magnitude(:, :, iFrame) = gmag;
    quiver(gx, -gy); %invert to correct visual vector orientation
    frames(cast(iFrame, 'uint16')) = getframe(gcf);
    writeVideo(v, frames(iFrame));
end
 close(v);
 delete(progressBar);

% Algorithm 2.1
angleRad = get_csd(magnitude, theta, THRESHOLD);                           %correct raw angles
angleDeg = rad2deg(angleRad);                                             %convert angles to degrees

% Plot estimated cloud shadow direction
figure(figFmt);
hist = polarhistogram(angleRad, 10);
set(gca, 'FontSize', 10)
saveas(gca, fullfile(OUTPUT_DIR, 'frame - 1'), 'fig');                          %save figure
saveas(gca, fullfile(OUTPUT_DIR, 'frame - 1'), 'png');                          %save image

% Algorithm 2.2
[M, phaseRad] =  get_resultant_vec(magnitude, theta);
phaseDeg = rad2deg(phaseRad);

% Plot polar histogram
figure(figFmt);
histo = polarhistogram(phaseRad, [0.3926991 1.178097 1.9634954 2.7488936... %set bin edges
                       3.5342917 4.3196899 5.1050881 5.8904862 6.6758844]);
% histo = polarhistogram(phaseRad, 10);
set(gca, 'FontSize', 10)
saveas(gca, fullfile(OUTPUT_DIR, 'frame - 2'), 'fig');                          %save figure
saveas(gca, fullfile(OUTPUT_DIR, 'frame - 2'), 'png');                          %save image

%% Find the optical flow
% OpF =  get_optical_flow(imData);
%  get_vid(OpF, strcat(OUTPUT_DIR, 'OpticalFlow'));                          %save OpF run as .AVI file

%% Get cmv final direction and speed
cmvDirection1 = get_cmv_direction(angleRad, hist, 1);
cmvDirection2 = get_cmv_direction(phaseRad, histo, 2);
cmvSpeed1 = get_cmv_speed(cmvDirection1, dipLocArr);
cmvSpeed2 = get_cmv_speed(cmvDirection2, dipLocArr);
cmvSpeed1 = fillmissing(cmvSpeed1, "nearest", EndValues='nearest');
cmvSpeed2 = fillmissing(cmvSpeed2, "nearest", EndValues='nearest');
cmv = [cmvDirection1 cmvDirection2 cmvSpeed1 cmvSpeed2];

% Save cmv array to a text file
fileID = fopen(strcat(OUTPUT_DIR, 'cmv.txt'), 'w');
fprintf(fileID, '%6s %6s %6s %6s\n', 'CMV_Direction1', 'CMV_Direction2', 'CMV_Speed1', 'CMV_Speed2');
fprintf(fileID, '%0.2f %0.2f %0.2f %0.2f\n', cmv);
fclose(fileID);
%([A - Z])([A - Z] + )_([A - Z])?([A - Za - z0 - 9] * )_?(? = \()
%\ (\S * ?)
%\([a - z][a - z0 - 9] * )([A - Z][a - z0 - 9] * )([A - Z][a - z0 - 9] * )?(? = \()



%[A - Z]([A - Z0 - 9] * [a - z][a - z0 - 9] * [A - Z]|[a - z0 - 9] * [A - Z][A - Z0 - 9] * [a - z])[A - Za - z0 - 9]*